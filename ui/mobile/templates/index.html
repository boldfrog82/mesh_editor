<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ scene_name }} – Mobile Viewer</title>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <header class="app-header">
      <h1>Mesh Viewer</h1>
      <p class="subtitle">Interactive preview optimised for mobile browsers.</p>
    </header>

    <main>
      <section class="viewer-wrapper">
        <div id="viewer"></div>
        <div id="loading" role="status">Loading scene…</div>
      </section>

      <section class="instructions">
        <h2>How to use</h2>
        <ol>
          <li>Drag with one finger to orbit around the model.</li>
          <li>Drag with two fingers to pan the camera.</li>
          <li>Pinch with two fingers to zoom in or out.</li>
          <li>Tap the refresh button below if you update the desktop scene.</li>
        </ol>
        <button id="refresh">Refresh scene</button>
      </section>
    </main>

    <footer>
      <small>Served from {{ scene_name }} at {{ now }}.</small>
    </footer>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js";

      const viewer = document.getElementById("viewer");
      const loading = document.getElementById("loading");
      const refreshButton = document.getElementById("refresh");

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(viewer.clientWidth, viewer.clientHeight);
      viewer.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111827);

      const camera = new THREE.PerspectiveCamera(60, viewer.clientWidth / viewer.clientHeight, 0.1, 1000);
      camera.position.set(4, 3, 6);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enablePan = true;
      controls.minDistance = 1;
      controls.maxDistance = 40;

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
      keyLight.position.set(5, 10, 7);
      scene.add(keyLight);

      const rimLight = new THREE.DirectionalLight(0x7dd3fc, 0.3);
      rimLight.position.set(-4, 6, -6);
      scene.add(rimLight);

      const grid = new THREE.GridHelper(20, 20, 0x4ade80, 0x1f2937);
      grid.material.opacity = 0.35;
      grid.material.transparent = true;
      grid.position.y = -0.5;
      scene.add(grid);

      let meshGroup = new THREE.Group();
      scene.add(meshGroup);

      async function loadScene() {
        loading.hidden = false;
        refreshButton.disabled = true;

        try {
          const response = await fetch("/api/scene");
          if (!response.ok) {
            throw new Error(`Failed to load scene: ${response.status}`);
          }
          const data = await response.json();
          rebuildScene(data);
        } catch (error) {
          loading.textContent = error.message;
          console.error(error);
        } finally {
          refreshButton.disabled = false;
          if (meshGroup.children.length > 0) {
            setTimeout(() => {
              loading.hidden = true;
              loading.textContent = "Loading scene…";
            }, 300);
          }
        }
      }

      function rebuildScene(data) {
        meshGroup.clear();

        let hasGeometry = false;
        (data.meshes || []).forEach((meshData) => {
          const geometry = new THREE.BufferGeometry();
          const positions = meshData.vertices.flat();
          const indices = [];

          meshData.faces.forEach((face) => {
            if (face.length === 3) {
              indices.push(face[0], face[1], face[2]);
            } else if (face.length === 4) {
              indices.push(face[0], face[1], face[2], face[0], face[2], face[3]);
            }
          });

          geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
          if (indices.length > 0) {
            geometry.setIndex(indices);
          }
          geometry.computeVertexNormals();

          const material = new THREE.MeshStandardMaterial({
            color: 0x60a5fa,
            roughness: 0.45,
            metalness: 0.1,
          });

          const wireframe = new THREE.LineSegments(
            new THREE.EdgesGeometry(geometry),
            new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true })
          );

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.fromArray(meshData.transform.position);
          mesh.rotation.set(
            meshData.transform.rotation[0],
            meshData.transform.rotation[1],
            meshData.transform.rotation[2]
          );
          mesh.scale.fromArray(meshData.transform.scale);

          wireframe.position.copy(mesh.position);
          wireframe.rotation.copy(mesh.rotation);
          wireframe.scale.copy(mesh.scale);

          meshGroup.add(mesh);
          meshGroup.add(wireframe);
          hasGeometry = true;
        });

        if (data.camera && data.camera.transform) {
          const pos = data.camera.transform.position;
          camera.position.set(pos[0], pos[1], pos[2]);
          controls.target.set(0, 0, 0);
          controls.update();
        }

        if (!hasGeometry) {
          loading.hidden = false;
          loading.textContent = "No meshes available yet.";
        }
      }

      function onWindowResize() {
        const { clientWidth, clientHeight } = viewer;
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight);
      }

      refreshButton.addEventListener("click", loadScene);
      window.addEventListener("resize", onWindowResize);

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      onWindowResize();
      loadScene();
      animate();
    </script>
  </body>
</html>
